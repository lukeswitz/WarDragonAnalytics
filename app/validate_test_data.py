#!/usr/bin/env python3
"""
Validation script for test data generated by test_data_generator.py

Checks that generated data looks realistic and matches expected patterns.
"""

import sys

try:
    import psycopg2
    from psycopg2.extras import RealDictCursor
except ImportError:
    print("Error: psycopg2 not installed. Install with: pip install psycopg2-binary", file=sys.stderr)
    sys.exit(1)


def connect_db(db_url):
    """Connect to database."""
    return psycopg2.connect(db_url)


def validate_kits(conn):
    """Validate kit records."""
    print("\n" + "="*60)
    print("VALIDATING KITS")
    print("="*60)

    with conn.cursor(cursor_factory=RealDictCursor) as cur:
        cur.execute("SELECT COUNT(*) as count FROM kits")
        kit_count = cur.fetchone()['count']
        print(f"✓ Kit count: {kit_count}")

        cur.execute("SELECT * FROM kits ORDER BY kit_id")
        kits = cur.fetchall()

        for kit in kits:
            print(f"\n  Kit: {kit['kit_id']}")
            print(f"    Name: {kit['name']}")
            print(f"    Location: {kit['location']}")
            print(f"    Status: {kit['status']}")
            print(f"    Last seen: {kit['last_seen']}")

    return kit_count > 0


def validate_drones(conn):
    """Validate drone records."""
    print("\n" + "="*60)
    print("VALIDATING DRONES")
    print("="*60)

    with conn.cursor(cursor_factory=RealDictCursor) as cur:
        # Count total records
        cur.execute("SELECT COUNT(*) as count FROM drones")
        total = cur.fetchone()['count']
        print(f"✓ Total drone records: {total:,}")

        # Count unique drones
        cur.execute("SELECT COUNT(DISTINCT drone_id) as count FROM drones")
        unique_drones = cur.fetchone()['count']
        print(f"✓ Unique drones: {unique_drones}")

        # Check makes/models
        cur.execute("""
            SELECT rid_make, rid_model, COUNT(*) as count
            FROM drones
            GROUP BY rid_make, rid_model
            ORDER BY count DESC
            LIMIT 10
        """)
        makes_models = cur.fetchall()
        print(f"\n  Top makes/models:")
        for mm in makes_models:
            print(f"    {mm['rid_make']} {mm['rid_model']}: {mm['count']:,} records")

        # Check time range
        cur.execute("SELECT MIN(time) as start_time, MAX(time) as end_time FROM drones")
        time_range = cur.fetchone()
        print(f"\n  Time range:")
        print(f"    Start: {time_range['start_time']}")
        print(f"    End: {time_range['end_time']}")

        # Check GPS bounds (sanity check)
        cur.execute("""
            SELECT
                MIN(lat) as min_lat, MAX(lat) as max_lat,
                MIN(lon) as min_lon, MAX(lon) as max_lon,
                MIN(alt) as min_alt, MAX(alt) as max_alt
            FROM drones
        """)
        bounds = cur.fetchone()
        print(f"\n  GPS bounds:")
        print(f"    Latitude: {bounds['min_lat']:.4f} to {bounds['max_lat']:.4f}")
        print(f"    Longitude: {bounds['min_lon']:.4f} to {bounds['max_lon']:.4f}")
        print(f"    Altitude: {bounds['min_alt']:.1f}m to {bounds['max_alt']:.1f}m")

        # Validate ranges
        issues = []
        if not (-90 <= bounds['min_lat'] <= 90 and -90 <= bounds['max_lat'] <= 90):
            issues.append("Invalid latitude range")
        if not (-180 <= bounds['min_lon'] <= 180 and -180 <= bounds['max_lon'] <= 180):
            issues.append("Invalid longitude range")
        if not (0 <= bounds['min_alt'] <= 500 and 0 <= bounds['max_alt'] <= 500):
            issues.append("Suspicious altitude range")

        # Check speed ranges
        cur.execute("SELECT MIN(speed) as min_speed, MAX(speed) as max_speed FROM drones WHERE speed IS NOT NULL")
        speeds = cur.fetchone()
        print(f"\n  Speed range: {speeds['min_speed']:.1f} to {speeds['max_speed']:.1f} m/s")
        if speeds['max_speed'] > 50:
            issues.append("Unrealistic speed detected")

        # Check RSSI
        cur.execute("SELECT MIN(rssi) as min_rssi, MAX(rssi) as max_rssi FROM drones WHERE rssi IS NOT NULL")
        rssi = cur.fetchone()
        print(f"  RSSI range: {rssi['min_rssi']} to {rssi['max_rssi']} dBm")
        if rssi['min_rssi'] < -100 or rssi['max_rssi'] > 0:
            issues.append("Suspicious RSSI range")

        if issues:
            print(f"\n  ⚠ Issues found:")
            for issue in issues:
                print(f"    - {issue}")
            return False

    return True


def validate_signals(conn):
    """Validate FPV signal records."""
    print("\n" + "="*60)
    print("VALIDATING SIGNALS")
    print("="*60)

    with conn.cursor(cursor_factory=RealDictCursor) as cur:
        # Count total records
        cur.execute("SELECT COUNT(*) as count FROM signals")
        total = cur.fetchone()['count']
        print(f"✓ Total signal records: {total:,}")

        if total == 0:
            print("  ⚠ No signal records found (may be expected if signal_probability=0)")
            return True

        # Check detection types
        cur.execute("""
            SELECT detection_type, COUNT(*) as count
            FROM signals
            GROUP BY detection_type
            ORDER BY count DESC
        """)
        types = cur.fetchall()
        print(f"\n  Detection types:")
        for t in types:
            print(f"    {t['detection_type']}: {t['count']:,} records")

        # Check frequency ranges
        cur.execute("""
            SELECT
                MIN(freq_mhz) as min_freq,
                MAX(freq_mhz) as max_freq,
                AVG(freq_mhz) as avg_freq
            FROM signals
        """)
        freqs = cur.fetchone()
        print(f"\n  Frequency range:")
        print(f"    Min: {freqs['min_freq']:.1f} MHz")
        print(f"    Max: {freqs['max_freq']:.1f} MHz")
        print(f"    Avg: {freqs['avg_freq']:.1f} MHz")

        # Validate frequency range (should be 5.3-5.9 GHz for FPV)
        issues = []
        if freqs['min_freq'] < 5300 or freqs['max_freq'] > 6000:
            issues.append("Frequency outside expected FPV range (5.3-6.0 GHz)")

        # Check power levels
        cur.execute("""
            SELECT MIN(power_dbm) as min_power, MAX(power_dbm) as max_power
            FROM signals
            WHERE power_dbm IS NOT NULL
        """)
        power = cur.fetchone()
        print(f"  Power range: {power['min_power']:.1f} to {power['max_power']:.1f} dBm")

        if power['min_power'] < -100 or power['max_power'] > 0:
            issues.append("Suspicious power range")

        if issues:
            print(f"\n  ⚠ Issues found:")
            for issue in issues:
                print(f"    - {issue}")
            return False

    return True


def validate_health(conn):
    """Validate system health records."""
    print("\n" + "="*60)
    print("VALIDATING SYSTEM HEALTH")
    print("="*60)

    with conn.cursor(cursor_factory=RealDictCursor) as cur:
        # Count total records
        cur.execute("SELECT COUNT(*) as count FROM system_health")
        total = cur.fetchone()['count']
        print(f"✓ Total health records: {total:,}")

        # Check ranges
        cur.execute("""
            SELECT
                MIN(cpu_percent) as min_cpu, MAX(cpu_percent) as max_cpu,
                MIN(memory_percent) as min_mem, MAX(memory_percent) as max_mem,
                MIN(disk_percent) as min_disk, MAX(disk_percent) as max_disk,
                MIN(temp_cpu) as min_temp_cpu, MAX(temp_cpu) as max_temp_cpu,
                MIN(uptime_hours) as min_uptime, MAX(uptime_hours) as max_uptime
            FROM system_health
        """)
        stats = cur.fetchone()

        print(f"\n  CPU usage: {stats['min_cpu']:.1f}% to {stats['max_cpu']:.1f}%")
        print(f"  Memory usage: {stats['min_mem']:.1f}% to {stats['max_mem']:.1f}%")
        print(f"  Disk usage: {stats['min_disk']:.1f}% to {stats['max_disk']:.1f}%")
        print(f"  CPU temp: {stats['min_temp_cpu']:.1f}°C to {stats['max_temp_cpu']:.1f}°C")
        print(f"  Uptime: {stats['min_uptime']:.2f}h to {stats['max_uptime']:.2f}h")

        issues = []
        if stats['max_cpu'] > 100 or stats['min_cpu'] < 0:
            issues.append("Invalid CPU percentage")
        if stats['max_mem'] > 100 or stats['min_mem'] < 0:
            issues.append("Invalid memory percentage")
        if stats['max_disk'] > 100 or stats['min_disk'] < 0:
            issues.append("Invalid disk percentage")
        if stats['max_temp_cpu'] > 150 or stats['min_temp_cpu'] < 0:
            issues.append("Unrealistic CPU temperature")

        if issues:
            print(f"\n  ⚠ Issues found:")
            for issue in issues:
                print(f"    - {issue}")
            return False

    return True


def main():
    """Main validation routine."""
    import argparse

    parser = argparse.ArgumentParser(description="Validate WarDragon Analytics test data")
    parser.add_argument(
        "--db-url",
        type=str,
        default="postgresql://wardragon:wardragon@localhost:5432/wardragon",
        help="Database URL"
    )
    args = parser.parse_args()

    print("="*60)
    print("WARDRAGON ANALYTICS TEST DATA VALIDATOR")
    print("="*60)
    print(f"\nConnecting to database...")

    try:
        conn = connect_db(args.db_url)
        print(f"✓ Connected successfully")

        # Run validations
        results = {
            "kits": validate_kits(conn),
            "drones": validate_drones(conn),
            "signals": validate_signals(conn),
            "health": validate_health(conn),
        }

        # Summary
        print("\n" + "="*60)
        print("VALIDATION SUMMARY")
        print("="*60)

        all_passed = all(results.values())

        for table, passed in results.items():
            status = "✓ PASS" if passed else "✗ FAIL"
            print(f"{status}: {table}")

        if all_passed:
            print("\n✓ All validations passed!")
            print("\nTest data looks realistic and ready for use.")
            return 0
        else:
            print("\n⚠ Some validations failed. Review issues above.")
            return 1

    except psycopg2.Error as e:
        print(f"\n✗ Database error: {e}", file=sys.stderr)
        return 1
    except KeyboardInterrupt:
        print("\n\nInterrupted by user")
        return 1
    except Exception as e:
        print(f"\n✗ Error: {e}", file=sys.stderr)
        import traceback
        traceback.print_exc()
        return 1
    finally:
        if 'conn' in locals():
            conn.close()


if __name__ == "__main__":
    sys.exit(main())
